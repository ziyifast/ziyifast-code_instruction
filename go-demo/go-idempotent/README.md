Goè¯­è¨€å¹‚ç­‰æ€§å®ç°æŒ‡å—

1. ä»€ä¹ˆæ˜¯å¹‚ç­‰æ€§ï¼Ÿ
   å¹‚ç­‰æ€§ï¼ˆIdempotenceï¼‰ æ˜¯æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦ä¸­çš„é‡è¦æ¦‚å¿µï¼ŒæŒ‡çš„æ˜¯ä¸€ä¸ªæ“ä½œæ‰§è¡Œå¤šæ¬¡ä¸æ‰§è¡Œä¸€æ¬¡çš„æ•ˆæœç›¸åŒã€‚
   åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿå’ŒAPIè®¾è®¡ä¸­ï¼Œå¹‚ç­‰æ€§æ„å‘³ç€ï¼š
- å®¢æˆ·ç«¯å¯¹åŒä¸€æ“ä½œå‘èµ·ä¸€æ¬¡æˆ–å¤šæ¬¡è¯·æ±‚çš„ç»“æœå®Œå…¨ä¸€è‡´
- ä¸ä¼šå› ä¸ºå¤šæ¬¡è°ƒç”¨è€Œäº§ç”Ÿå‰¯ä½œç”¨ï¼ˆå¦‚é‡å¤æ‰£æ¬¾ã€é‡å¤åˆ›å»ºèµ„æºç­‰ï¼‰
- æ˜¯æ„å»ºå¯é åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºçŸ³

æ¥å£å¹‚ç­‰æ€§å°±æ˜¯ç”¨æˆ·å¯¹äºåŒä¸€æ“ä½œå‘èµ·çš„ä¸€æ¬¡è¯·æ±‚æˆ–è€…å¤šæ¬¡è¯·æ±‚çš„ç»“æœæ˜¯ä¸€è‡´çš„ï¼Œä¸ä¼šå› ä¸ºå¤šæ¬¡ç‚¹å‡»è€Œäº§ç”Ÿäº†å‰¯ä½œç”¨ã€‚ä¸¾ä¸ªæœ€ç®€å•çš„ä¾‹å­ï¼Œæ”¯ä»˜è¿‡ç¨‹ä¸­ï¼Œç”¨æˆ·è´­ä¹°å•†å“åæ”¯ä»˜ï¼Œæ”¯ä»˜æ‰£æ¬¾æˆåŠŸï¼Œä½†æ˜¯è¿”å›ç»“æœçš„æ—¶å€™ç½‘ç»œå¼‚å¸¸ï¼Œæ­¤æ—¶é’±å·²ç»æ‰£äº†ï¼Œç”¨æˆ·å†æ¬¡ç‚¹å‡»æŒ‰é’®ï¼Œæ­¤æ—¶ä¼šè¿›è¡Œç¬¬äºŒæ¬¡æ‰£æ¬¾ï¼Œè¿”å›ç»“æœæˆåŠŸï¼Œç”¨æˆ·æŸ¥è¯¢ä½™é¢è¿”å‘ç°å¤šæ‰£é’±äº†ï¼Œæµæ°´è®°å½•ä¹Ÿå˜æˆäº†ä¸¤æ¡ï¼Œè¿™å°±æ²¡æœ‰ä¿è¯æ¥å£çš„å¹‚ç­‰æ€§ã€‚
ç®€å•çš„è¯´å°±æ˜¯ ä¸€ä¸ªç”¨æˆ·å¯¹äºåŒä¸€ä¸ªæ“ä½œå‘èµ·ä¸€æ¬¡æˆ–å¤šæ¬¡çš„è¯·æ±‚ï¼Œè¯·æ±‚çš„ç»“æœä¸€è‡´ã€‚ä¸ä¼šå› ä¸ºå¤šæ¬¡ç‚¹å‡»è€Œäº§ç”Ÿå¤šæ¡æ•°æ®ã€‚

2. ä¸ºä»€ä¹ˆéœ€è¦å¹‚ç­‰æ€§ï¼Ÿ
   2.1 å¸¸è§åœºæ™¯
- ç½‘ç»œä¸ç¨³å®šï¼šå®¢æˆ·ç«¯è¶…æ—¶é‡è¯•
- ç”¨æˆ·é‡å¤æ“ä½œï¼šå¤šæ¬¡ç‚¹å‡»æäº¤æŒ‰é’®
- å¾®æœåŠ¡é‡è¯•æœºåˆ¶ï¼šæœåŠ¡é—´è°ƒç”¨è‡ªåŠ¨é‡è¯•
- æ¶ˆæ¯é˜Ÿåˆ—é‡å¤æ¶ˆè´¹ï¼šMQè‡³å°‘ä¸€æ¬¡æŠ•é€’è¯­ä¹‰

2.2 ç¼ºä¹å¹‚ç­‰æ€§çš„é£é™©
- âš ï¸é‡å¤æ‰£æ¬¾æˆ–æ”¯ä»˜
- âš ï¸é‡å¤åˆ›å»ºè®¢å•æˆ–èµ„æº
- âš ï¸æ•°æ®ä¸ä¸€è‡´çŠ¶æ€
- âš ï¸ç”¨æˆ·ä½“éªŒå·®ï¼ˆæ“ä½œç»“æœä¸ç¡®å®šï¼‰

2.3 éœ€è¦å¹‚ç­‰æ€§çš„æ¥å£
1. Get æ–¹æ³•ï¼šå¹‚ç­‰ã€‚ç”¨äºè·å–èµ„æºï¼Œå…¶ä¸€èˆ¬ä¸ä¼šä¹Ÿä¸åº”å½“å¯¹ç³»ç»Ÿèµ„æºè¿›è¡Œæ”¹å˜ï¼Œæ‰€ä»¥æ˜¯å¹‚ç­‰çš„ã€‚
2. Post æ–¹æ³•ï¼šéå¹‚ç­‰ã€‚ä¸€èˆ¬ç”¨äºåˆ›å»ºæ–°çš„èµ„æºã€‚å…¶æ¯æ¬¡æ‰§è¡Œéƒ½ä¼šæ–°å¢æ•°æ®ï¼Œæ‰€ä»¥ä¸æ˜¯å¹‚ç­‰çš„ã€‚
3. Put æ–¹æ³•ï¼šè§†æƒ…å†µè€Œå®šã€‚ä¸€èˆ¬ç”¨äºä¿®æ”¹èµ„æºã€‚è¯¥æ“ä½œåˆ™åˆ†æƒ…å†µæ¥åˆ¤æ–­æ˜¯ä¸æ˜¯æ»¡è¶³å¹‚ç­‰ï¼Œæ›´æ–°æ“ä½œä¸­ç›´æ¥æ ¹æ®æŸä¸ªå€¼è¿›è¡Œæ›´æ–°ï¼Œä¹Ÿèƒ½ä¿æŒå¹‚ç­‰ã€‚ä¸è¿‡æ‰§è¡Œç´¯åŠ æ“ä½œçš„æ›´æ–°æ˜¯éå¹‚ç­‰ã€‚
4. Delete æ–¹æ³•ï¼šè§†æƒ…å†µå®šã€‚ä¸€èˆ¬ç”¨äºåˆ é™¤èµ„æºã€‚è¯¥æ“ä½œåˆ™åˆ†æƒ…å†µæ¥åˆ¤æ–­æ˜¯ä¸æ˜¯æ»¡è¶³å¹‚ç­‰ï¼Œå½“æ ¹æ®å”¯ä¸€å€¼è¿›è¡Œåˆ é™¤æ—¶ï¼Œåˆ é™¤åŒä¸€ä¸ªæ•°æ®å¤šæ¬¡æ‰§è¡Œæ•ˆæœä¸€æ ·ã€‚ä¸è¿‡éœ€è¦æ³¨æ„ï¼Œå¸¦æŸ¥è¯¢æ¡ä»¶çš„åˆ é™¤åˆ™å°±ä¸ä¸€å®šæ»¡è¶³å¹‚ç­‰äº†ã€‚ä¾‹å¦‚åœ¨æ ¹æ®æ¡ä»¶åˆ é™¤ä¸€æ‰¹æ•°æ®åï¼Œè¿™æ—¶å€™æ–°å¢åŠ äº†ä¸€æ¡æ•°æ®ä¹Ÿæ»¡è¶³æ¡ä»¶ï¼Œç„¶ååˆæ‰§è¡Œäº†ä¸€æ¬¡åˆ é™¤ï¼Œé‚£ä¹ˆå°†ä¼šå¯¼è‡´æ–°å¢åŠ çš„è¿™æ¡æ»¡è¶³æ¡ä»¶æ•°æ®ä¹Ÿè¢«åˆ é™¤ã€‚

æ¥å£å¹‚ç­‰æ€§çš„å¤„ç†æ–¹å¼æœ‰å¾ˆå¤šï¼Œæ•°æ®åº“å”¯ä¸€ä¸»é”®ã€æ•°æ®åº“ä¹è§‚é”ã€ä»¤ç‰Œè¡¨+å”¯ä¸€çº¦æŸã€ä¸‹æ¸¸ä¼ é€’å”¯ä¸€åºåˆ—å·ã€åŒæ­¥é”ï¼ˆå•ä½“é¡¹ç›®ï¼‰ã€åˆ†å¸ƒå¼é”å¦‚redis ç­‰ç­‰ï¼Œè¿™é‡Œåªè¯¦ç»†é˜è¿°ä½¿ç”¨tokenä»¤ç‰Œçš„æ–¹å¼ï¼š
[å›¾ç‰‡]
æ•´ä½“æµç¨‹ï¼š
1. å®¢æˆ·ç«¯è¯·æ±‚æœåŠ¡å™¨æ¥å£è·å–tokenã€‚
2. æœåŠ¡å™¨å°†tokenè¿”ç»™å®¢æˆ·ç«¯çš„åŒæ—¶å°†ä¿¡æ¯ï¼ˆè¿™é‡ŒåŒ…æ‹¬ç”¨æˆ·ä¿¡æ¯ã€å’Œtokenï¼‰å­˜å‚¨åˆ°redisä¸­ã€‚
3. è¯·æ±‚ä¸šåŠ¡æ¥å£æ—¶ï¼Œå°†tokenæ”¾å…¥headerä¸­è¿›è¡Œæ¥å£è¯·æ±‚ã€‚
4. æœåŠ¡å™¨é€šè¿‡ç”¨æˆ·ä¿¡æ¯å’Œtokenæ£€æŸ¥tokenæ˜¯å¦è¿˜å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨å°±åˆ é™¤ï¼Œå¦‚æœä¸å­˜åœ¨ç›´æ¥è¿”å›ç»“æœã€‚
5. å“åº”æœåŠ¡å™¨è¯·æ±‚ç»“æœã€‚



3. å¸¸è§çš„é”™è¯¯å®ç°æ–¹å¼

3.1 å®Œå…¨æ²¡æœ‰å¹‚ç­‰æ€§ä¿è¯
func (ps *PaymentService) ProcessPaymentWithoutIdempotent(request PaymentRequest) PaymentResult {
// ç›´æ¥å¤„ç†æ”¯ä»˜ï¼Œæ²¡æœ‰å¹‚ç­‰æ€§æ£€æŸ¥
// æ¯æ¬¡è°ƒç”¨éƒ½ä¼šæ‰§è¡Œå®Œæ•´çš„æ”¯ä»˜æµç¨‹
// ç”¨æˆ·é‡å¤ç‚¹å‡»ä¼šå¤šæ¬¡æ‰£æ¬¾
return ps.executePayment(request)
}
é—®é¢˜ï¼šç”¨æˆ·é‡å¤ç‚¹å‡»ä¼šå¤šæ¬¡æ‰£æ¬¾ã€‚

3.2 ç®€å•å»é‡æ–¹æ¡ˆ
func (ps *PaymentService) ProcessPaymentWithSimpleDedup(request PaymentRequest) PaymentResult {
// ç®€å•ç”¨ç”¨æˆ·ID+é‡‘é¢åškey
key := fmt.Sprintf("payment:%d:%.2f", request.UserID, request.Amount)

    // å¦‚æœkeyå­˜åœ¨ï¼Œè®¤ä¸ºæ˜¯é‡å¤è¯·æ±‚
    if _, exists := ps.records[key]; exists {
        return PaymentResult{Status: "DUPLICATE"}
    }
    
    // å¤„ç†æ”¯ä»˜å¹¶è®°å½•
    result := ps.executePayment(request)
    ps.records[key] = true
    return result
}
é—®é¢˜ï¼š
- ç”¨æˆ·æ— æ³•è¿ç»­æ”¯ä»˜ç›¸åŒé‡‘é¢
- å¤„ç†å¤±è´¥åæ— æ³•é‡è¯•
- æ— æ³•åŒºåˆ†ä¸åŒä¸šåŠ¡è¯·æ±‚

3.3 è€ƒè™‘ä¸å‘¨çš„å¹‚ç­‰tokenæ–¹æ¡ˆ
func (ps *PaymentService) ProcessPaymentWithFlawedToken(request PaymentRequest) PaymentResult {
// æ£€æŸ¥tokenæ˜¯å¦å·²ä½¿ç”¨
if result, exists := ps.records[request.IdempotentToken]; exists {
return *result
}

    // å¤„ç†æ”¯ä»˜é€»è¾‘...
    result := ps.executePayment(request)
    
    // ä¿å­˜ç»“æœ
    ps.records[request.IdempotentToken] = &result
    return result
}

é—®é¢˜ï¼š
- âŒ å­˜åœ¨å¹¶å‘é—®é¢˜ï¼Œå¤šä¸ªè¯·æ±‚å¯èƒ½åŒæ—¶é€šè¿‡æ£€æŸ¥
- âŒ å¤±è´¥åæ— æ³•é‡è¯•ï¼ˆä¸€æ—¦è®°å½•ï¼Œæ°¸è¿œè¿”å›ç›¸åŒç»“æœï¼‰
- âŒ ç¼ºä¹çŠ¶æ€ç®¡ç†

4. æ­£ç¡®çš„å¹‚ç­‰æ€§å®ç°
   æ ¸å¿ƒåŸåˆ™ï¼š
1. å…ˆæŸ¥åæ‰§è¡Œï¼šåœ¨è·å–é”ä¹‹å‰å…ˆæŸ¥è¯¢æ˜¯å¦å·²æœ‰å¤„ç†ç»“æœ
2. åŒé‡æ£€æŸ¥ï¼šè·å–é”åå†æ¬¡æ£€æŸ¥ç»“æœï¼Œé¿å…å¹¶å‘é—®é¢˜
3. çŠ¶æ€ç®¡ç†ï¼šåŒºåˆ†å¤„ç†ä¸­ã€æˆåŠŸã€å¤±è´¥ç­‰çŠ¶æ€
4. å…è®¸é‡è¯•ï¼šå¤±è´¥çš„è¯·æ±‚åº”å…è®¸ç”¨æˆ·é‡è¯•ï¼ˆæ ¹æ®ä¸šåŠ¡éœ€æ±‚ï¼‰
5. è¶…æ—¶æœºåˆ¶ï¼šå¤„ç†ä¸­çš„è¯·æ±‚åº”æœ‰è¶…æ—¶æ—¶é—´ï¼Œé˜²æ­¢å¡æ­»
   4.1 å¸¸è§æ–¹æ¡ˆä»‹ç»
   [å›¾ç‰‡]
   ğŸ“¢è¯·æ³¨æ„ï¼šä¸‹é¢å„æ–¹æ¡ˆå®é™…æµç¨‹è¿˜éœ€è¦è´´åˆå„è‡ªçœŸå®ä¸šåŠ¡åœºæ™¯ï¼Œå¯é€‚å½“å¢åŠ æˆ–å‡å°‘å…¶ä¸­çš„æµç¨‹
   ç›®å‰ä¸šå†…ä¸»æµçš„å¹‚ç­‰æ€§å®ç°æ–¹æ¡ˆä¸»è¦åŒ…å«ä»¥ä¸‹å‡ ç§ï¼š
1.  select+insert+ä¸»é”®/å”¯ä¸€ç´¢å¼•å†²çª
2. ç›´æ¥insert + ä¸»é”®/å”¯ä¸€ç´¢å¼•å†²çª
3. çŠ¶æ€æœºå¹‚ç­‰
4. æŠ½å–é˜²é‡è¡¨
5. tokenä»¤ç‰Œ
6. æ‚²è§‚é”(å¦‚select for update)
7. ä¹è§‚é”
8. åˆ†å¸ƒå¼é”
   ...
   æ–¹æ¡ˆ
   é€‚ç”¨åœºæ™¯
   æ€§èƒ½
   å¤æ‚åº¦
   ä¸€è‡´æ€§
   SELECT+INSERT
   ç®€å•ä¸šåŠ¡
   ä¸­
   ä½
   é«˜
   ç›´æ¥INSERT
   é«˜å¹¶å‘
   é«˜
   ä½
   é«˜
   çŠ¶æ€æœº
   å¤æ‚çŠ¶æ€æµè½¬
   ä¸­
   ä¸­
   é«˜
   é˜²é‡è¡¨
   å¤æ‚ä¸šåŠ¡
   ä¸­
   ä¸­
   é«˜
   Tokenä»¤ç‰Œ
   å®¢æˆ·ç«¯å‚ä¸
   é«˜
   ä¸­
   é«˜
   æ‚²è§‚é”
   å¼ºä¸€è‡´æ€§
   ä½
   ä½
   æœ€é«˜
   ä¹è§‚é”
   è¯»å¤šå†™å°‘
   é«˜
   ä¸­
   é«˜
   åˆ†å¸ƒå¼é”
   åˆ†å¸ƒå¼ç¯å¢ƒ
   ä¸­
   é«˜
   é«˜

ä½¿ç”¨å»ºè®®ï¼š
ç®€å•åœºæ™¯ï¼šä½¿ç”¨ç›´æ¥INSERT + å”¯ä¸€ç´¢å¼•
å¤æ‚ä¸šåŠ¡ï¼šä½¿ç”¨çŠ¶æ€æœº + é˜²é‡è¡¨
é«˜å¹¶å‘åœºæ™¯ï¼šä½¿ç”¨Tokenä»¤ç‰Œ + åˆ†å¸ƒå¼é”
åˆ†å¸ƒå¼ç³»ç»Ÿï¼šä½¿ç”¨åˆ†å¸ƒå¼é” + æ¶ˆæ¯é˜Ÿåˆ—å¹‚ç­‰
å‰ç«¯äº¤äº’ï¼šä½¿ç”¨Tokenä»¤ç‰Œ + å®¢æˆ·ç«¯é˜²é‡

1. SELECT+INSERT
   æ¦‚å¿µï¼šäº¤æ˜“è¯·æ±‚è¿‡æ¥ï¼Œä¼šå…ˆæ ¹æ®è¯·æ±‚çš„å”¯ä¸€æµæ°´å· bizSeqå­—æ®µï¼Œå…ˆselectä¸€ä¸‹æ•°æ®åº“çš„æµæ°´è¡¨
- å¦‚æœæ•°æ®å·²ç»å­˜åœ¨ï¼Œå°±æ‹¦æˆªæ˜¯é‡å¤è¯·æ±‚ï¼Œç›´æ¥è¿”å›æˆåŠŸï¼›
- å¦‚æœæ•°æ®ä¸å­˜åœ¨ï¼Œå°±æ‰§è¡Œinsertæ’å…¥ï¼Œå¦‚æœinsertæˆåŠŸï¼Œåˆ™ç›´æ¥è¿”å›æˆåŠŸï¼Œå¦‚æœinsertäº§ç”Ÿä¸»é”®å†²çªå¼‚å¸¸ï¼Œåˆ™æ•è·å¼‚å¸¸ï¼Œæ¥ç€ç›´æ¥è¿”å›æˆåŠŸã€‚
  æµç¨‹å›¾ï¼š
  [å›¾ç‰‡]
  ä¼ªä»£ç ï¼š
  // å¹‚ç­‰å¤„ç†
  func idempotent(req Request) Response {
  // 1. æŸ¥è¯¢æ˜¯å¦å·²å¤„ç†
  record := selectByBizSeq(req.BizSeq)
  if record != nil {
  // é‡å¤è¯·æ±‚ï¼Œç›´æ¥è¿”å›æˆåŠŸ
  log.Info("é‡å¤è¯·æ±‚ï¼Œç›´æ¥è¿”å›æˆåŠŸï¼Œæµæ°´å·ï¼š{}", req.BizSeq)
  return successResponse
  }

  // 2. æ’å…¥è¯·æ±‚è®°å½•
  err := insert(req)
  if err != nil {
  // 3. ä¸»é”®å†²çªè¯´æ˜æ˜¯é‡å¤è¯·æ±‚
  if isDuplicateKeyError(err) {
  log.Info("ä¸»é”®å†²çªï¼Œæ˜¯é‡å¤è¯·æ±‚ï¼Œç›´æ¥è¿”å›æˆåŠŸï¼Œæµæ°´å·ï¼š{}", req.BizSeq)
  return successResponse
  }
  return errorResponse
  }

  // 4. æ­£å¸¸å¤„ç†è¯·æ±‚
  dealRequest(req)

  return successResponse
  }
2. ç›´æ¥insert + ä¸»é”®/å”¯ä¸€ç´¢å¼•å†²çª
   æ¦‚å¿µï¼šåœ¨ä¸Šé¢çš„æ–¹æ¡ˆä¸­æˆ‘ä»¬éƒ½ä¼šå…ˆæŸ¥ä¸€ä¸‹æµæ°´è¡¨çš„äº¤æ˜“è¯·æ±‚ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ï¼Œç„¶åä¸å­˜åœ¨å†æ’å…¥è¯·æ±‚è®°å½•ã€‚å¦‚æœé‡å¤è¯·æ±‚çš„æ¦‚ç‡æ¯”è¾ƒä½çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æ’å…¥è¯·æ±‚ï¼Œåˆ©ç”¨ä¸»é”®/å”¯ä¸€ç´¢å¼•å†²çªï¼Œå»åˆ¤æ–­æ˜¯é‡å¤è¯·æ±‚ã€‚
   æµç¨‹å›¾ï¼š
   [å›¾ç‰‡]
   PSï¼šé˜²é‡å’Œå¹‚ç­‰è®¾è®¡å…¶å®æ˜¯æœ‰åŒºåˆ«çš„ã€‚é˜²é‡ä¸»è¦ä¸ºäº†é¿å…äº§ç”Ÿé‡å¤æ•°æ®ï¼ŒæŠŠé‡å¤è¯·æ±‚æ‹¦æˆªä¸‹æ¥å³å¯ã€‚è€Œå¹‚ç­‰è®¾è®¡é™¤äº†æ‹¦æˆªå·²ç»å¤„ç†çš„è¯·æ±‚ï¼Œè¿˜è¦æ±‚æ¯æ¬¡ç›¸åŒçš„è¯·æ±‚éƒ½è¿”å›ä¸€æ ·çš„æ•ˆæœã€‚ä¸è¿‡å‘¢ï¼Œå¾ˆå¤šæ—¶å€™ï¼Œå®ƒä»¬çš„å¤„ç†æµç¨‹å¯ä»¥æ˜¯ç±»ä¼¼çš„ã€‚

ä¼ªä»£ç ï¼š
// å¹‚ç­‰å¤„ç†
func idempotent(req Request) Response {
// 1. ç›´æ¥æ’å…¥è¯·æ±‚è®°å½•
err := insert(req)
if err != nil {
// 2. ä¸»é”®å†²çªè¯´æ˜æ˜¯é‡å¤è¯·æ±‚
if isDuplicateKeyError(err) {
log.Info("ä¸»é”®å†²çªï¼Œæ˜¯é‡å¤è¯·æ±‚ï¼Œç›´æ¥è¿”å›æˆåŠŸï¼Œæµæ°´å·ï¼š{}", req.BizSeq)
return successResponse
}
return errorResponse
}

    // 3. æ­£å¸¸å¤„ç†è¯·æ±‚
    dealRequest(req)
    return successResponse
}

3. çŠ¶æ€æœºå¹‚ç­‰
   æ¦‚å¿µï¼šå¾ˆå¤šä¸šåŠ¡è¡¨ï¼Œéƒ½æ˜¯æœ‰çŠ¶æ€çš„ï¼Œæ¯”å¦‚è½¬è´¦æµæ°´è¡¨ï¼Œå°±ä¼šæœ‰0-å¾…å¤„ç†ï¼Œ1-å¤„ç†ä¸­ã€2-æˆåŠŸã€3-å¤±è´¥çŠ¶æ€ã€‚è½¬è´¦æµæ°´æ›´æ–°çš„æ—¶å€™ï¼Œéƒ½ä¼šæ¶‰åŠæµæ°´çŠ¶æ€æ›´æ–°ï¼Œå³æ¶‰åŠçŠ¶æ€æœº (å³çŠ¶æ€å˜æ›´å›¾)ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨çŠ¶æ€æœºå®ç°å¹‚ç­‰ï¼Œä¸€èµ·æ¥çœ‹ä¸‹å®ƒæ˜¯æ€ä¹ˆå®ç°çš„ã€‚
   æ¯”å¦‚è½¬è´¦æˆåŠŸåï¼ŒæŠŠå¤„ç†ä¸­çš„è½¬è´¦æµæ°´æ›´æ–°ä¸ºæˆåŠŸçŠ¶æ€ï¼ŒSQLè¿™ä¹ˆå†™ï¼š
   update transfr_flow set status=2 where biz_seq=â€˜666â€™ and status=1;
   æµç¨‹å›¾ï¼š
   [å›¾ç‰‡]
   ä¼ªä»£ç ï¼š
   åº•å±‚åŸç†ï¼šçŠ¶æ€æœºæ˜¯æ€ä¹ˆå®ç°å¹‚ç­‰çš„å‘¢ï¼Ÿ
- ç¬¬1æ¬¡è¯·æ±‚æ¥æ—¶ï¼ŒbizSeqæµæ°´å·æ˜¯ 666ï¼Œè¯¥æµæ°´çš„çŠ¶æ€æ˜¯å¤„ç†ä¸­ï¼Œå€¼æ˜¯ 1ï¼Œè¦æ›´æ–°ä¸º2-æˆåŠŸçš„çŠ¶æ€ï¼Œæ‰€ä»¥è¯¥updateè¯­å¥å¯ä»¥æ­£å¸¸æ›´æ–°æ•°æ®ï¼Œsqlæ‰§è¡Œç»“æœçš„å½±å“è¡Œæ•°æ˜¯1ï¼Œæµæ°´çŠ¶æ€æœ€åå˜æˆäº†2ã€‚
- ç¬¬2è¯·æ±‚ä¹Ÿè¿‡æ¥äº†ï¼Œå¦‚æœå®ƒçš„æµæ°´å·è¿˜æ˜¯ 666ï¼Œå› ä¸ºè¯¥æµæ°´çŠ¶æ€å·²ç»2-æˆåŠŸçš„çŠ¶æ€äº†ï¼Œæ‰€ä»¥æ›´æ–°ç»“æœæ˜¯0ï¼Œä¸ä¼šå†å¤„ç†ä¸šåŠ¡é€»è¾‘ï¼Œæ¥å£ç›´æ¥è¿”å›ã€‚
  // å¹‚ç­‰è½¬è´¦å¤„ç†
  func idempotentTransfer(req Request) Response {
  bizSeq := req.BizSeq

  // 1. æ›´æ–°çŠ¶æ€ï¼Œåªæœ‰çŠ¶æ€ä¸º1çš„è®°å½•æ‰èƒ½æ›´æ–°ä¸ºçŠ¶æ€2
  rows := update("transfr_flow set status=2 where biz_seq=? and status=1", bizSeq)

  if rows == 1 {
  log.Info("æ›´æ–°æˆåŠŸ,å¯ä»¥å¤„ç†è¯¥è¯·æ±‚")
  // å…¶ä»–ä¸šåŠ¡é€»è¾‘å¤„ç†
  return successResponse
  } else if rows == 0 {
  log.Info("æ›´æ–°ä¸æˆåŠŸï¼Œä¸å¤„ç†è¯¥è¯·æ±‚")
  // ä¸å¤„ç†ï¼Œç›´æ¥è¿”å›
  return successResponse
  }

  log.Warn("æ•°æ®å¼‚å¸¸")
  return successResponse
  }

4. æŠ½å–é˜²é‡è¡¨
   1å’Œ2çš„æ–¹æ¡ˆéƒ½æ˜¯å»ºç«‹åœ¨ä¸šåŠ¡æµæ°´è¡¨ä¸ŠbizSeqçš„å”¯ä¸€æ€§ä¸Šã€‚å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬ä¸šåŠ¡è¡¨å”¯ä¸€æµæ°´å·å¸Œæœ›åç«¯ç³»ç»Ÿç”Ÿæˆï¼Œåˆæˆ–è€…æˆ‘ä»¬å¸Œæœ›é˜²é‡åŠŸèƒ½ä¸ä¸šåŠ¡è¡¨åˆ†éš”å¼€æ¥ï¼Œè¿™æ—¶å€™æˆ‘ä»¬å¯ä»¥å•ç‹¬æä¸ªé˜²é‡è¡¨ã€‚å½“ç„¶é˜²é‡è¡¨ä¹Ÿæ˜¯åˆ©ç”¨ä¸»é”®/ç´¢å¼•çš„å”¯ä¸€æ€§ï¼Œå¦‚æœæ’å…¥é˜²é‡è¡¨å†²çªå³ç›´æ¥è¿”å›æˆåŠŸï¼Œå¦‚æœæ’å…¥æˆåŠŸï¼Œå³å»å¤„ç†è¯·æ±‚ã€‚
   æ¦‚å¿µï¼šé˜²é‡è¡¨æ˜¯ä¸€ç§ç‹¬ç«‹äºä¸šåŠ¡è¡¨çš„å¹‚ç­‰æ€§æ§åˆ¶æœºåˆ¶ï¼Œé€šè¿‡å•ç‹¬å»ºç«‹é˜²é‡è¡¨ï¼Œåˆ©ç”¨ä¸»é”®æˆ–å”¯ä¸€ç´¢å¼•çš„çº¦æŸç‰¹æ€§ï¼Œè¯·æ±‚å¤„ç†å‰å…ˆæ’å…¥é˜²é‡è®°å½•ï¼Œåˆ©ç”¨æ•°æ®åº“çº¦æŸæ£€æµ‹é‡å¤ï¼Œæ’å…¥å¤±è´¥è¡¨ç¤ºé‡å¤è¯·æ±‚ï¼Œç›´æ¥è¿”å›æˆåŠŸï¼›æ’å…¥æˆåŠŸåˆ™ç»§ç»­å¤„ç†ï¼Œå®ç°é˜²é‡é€»è¾‘ä¸ä¸šåŠ¡é€»è¾‘è§£è€¦ï¼Œé€‚ç”¨äºåç«¯ç”Ÿæˆå”¯ä¸€æµæ°´å·çš„åœºæ™¯


æµç¨‹å›¾ï¼š
[å›¾ç‰‡]

ä¼ªä»£ç ï¼š
// å¹‚ç­‰æ€§å¤„ç† - é˜²é‡è¡¨æ–¹å¼
func handleWithDedupTable(ctx context.Context, requestID string) error {
// 1. å¼€å§‹äº‹åŠ¡
tx := db.Begin()

    // 2. æ’å…¥é˜²é‡è¡¨è®°å½•
    err := tx.Exec("INSERT INTO dedup_table (request_id, create_time) VALUES (?, ?)", 
                   requestID, time.Now()).Error
    
    if err != nil {
        // 3. æ’å…¥å¤±è´¥è¡¨ç¤ºé‡å¤è¯·æ±‚ï¼Œå›æ»šäº‹åŠ¡å¹¶è¿”å›æˆåŠŸ
        tx.Rollback()
        return nil  // å¹‚ç­‰æ€§å¤„ç†ï¼šé‡å¤è¯·æ±‚ç›´æ¥è¿”å›æˆåŠŸ
    }
    
    // 4. æ’å…¥æˆåŠŸï¼Œæ‰§è¡Œä¸šåŠ¡é€»è¾‘
    bizErr := processBusinessLogic(tx, requestID)
    
    // 5. æ ¹æ®ä¸šåŠ¡å¤„ç†ç»“æœæäº¤æˆ–å›æ»šäº‹åŠ¡
    if bizErr != nil {
        tx.Rollback()
        return bizErr
    }
    
    tx.Commit()
    return nil
}

// é˜²é‡è¡¨ç»“æ„ç¤ºä¾‹
/*
CREATE TABLE dedup_table (
request_id VARCHAR(64) PRIMARY KEY,
create_time DATETIME NOT NULL,
INDEX idx_create_time (create_time)
);
*/



5. tokenä»¤ç‰Œ
   æ¦‚å¿µï¼štoken ä»¤ç‰Œæ–¹æ¡ˆä¸€èˆ¬åŒ…æ‹¬ä¸¤ä¸ªè¯·æ±‚é˜¶æ®µã€‚é˜¶æ®µä¸€æ˜¯å®¢æˆ·ç«¯è¯·æ±‚ç”³è¯·è·å–tokenï¼ŒæœåŠ¡ç«¯ç”Ÿæˆtokenè¿”å›ã€‚é˜¶æ®µäºŒæ˜¯å®¢æˆ·ç«¯å¸¦ç€tokenè¯·æ±‚ï¼ŒæœåŠ¡ç«¯æ ¡éªŒtokenã€‚è¯¦ç»†æµç¨‹ï¼š
1. å®¢æˆ·ç«¯å‘èµ·è¯·æ±‚ï¼Œç”³è¯·è·å–tokenã€‚
2. æœåŠ¡ç«¯ç”Ÿæˆå…¨å±€å”¯ä¸€çš„tokenï¼Œä¿å­˜åˆ°redisä¸­ï¼ˆä¸€èˆ¬ä¼šè®¾ç½®ä¸€ä¸ªè¿‡æœŸæ—¶é—´ï¼‰ï¼Œç„¶åè¿”å›ç»™å®¢æˆ·ç«¯ã€‚
3. å®¢æˆ·ç«¯å¸¦ç€tokenï¼Œå‘èµ·è¯·æ±‚ã€‚
4. æœåŠ¡ç«¯å»redisç¡®è®¤tokenæ˜¯å¦å­˜åœ¨ï¼Œä¸€èˆ¬ç”¨ redis.del(token)çš„æ–¹å¼ï¼Œå¦‚æœå­˜åœ¨ä¼šåˆ é™¤æˆåŠŸï¼Œå³å¤„ç†ä¸šåŠ¡é€»è¾‘ï¼Œå¦‚æœåˆ é™¤å¤±è´¥ä¸å¤„ç†ä¸šåŠ¡é€»è¾‘ï¼Œç›´æ¥è¿”å›ç»“æœã€‚

æµç¨‹å›¾ï¼š
[å›¾ç‰‡]
ä¼ªä»£ç ï¼š
// Tokenä»¤ç‰Œæ–¹å¼å¹‚ç­‰å¤„ç†

// 1. ç”³è¯·token
func applyToken() string {
// ç”Ÿæˆå…¨å±€å”¯ä¸€token
token := generateUniqueToken()

    // ä¿å­˜åˆ°redisï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´
    redis.Set(token, "unused", 24*time.Hour)
    
    return token
}

// 2. å¹‚ç­‰å¤„ç†
func idempotentProcess(req Request) Response {
token := req.Token

    // æ ¡éªŒtokenæ˜¯å¦å­˜åœ¨
    deleted := redis.Del(token)
    if deleted > 0 {
        // tokenå­˜åœ¨ï¼Œå¤„ç†ä¸šåŠ¡é€»è¾‘
        processBusinessLogic(req)
        return successResponse
    } else {
        // tokenä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›æˆåŠŸ
        log.Info("tokenå·²ä½¿ç”¨æˆ–ä¸å­˜åœ¨ï¼Œå¹‚ç­‰è¿”å›")
        return successResponse
    }
}

6. æ‚²è§‚é”(å¦‚select for update)
   æ¦‚å¿µï¼šé€šä¿—ç‚¹è®²å°±æ˜¯å¾ˆæ‚²è§‚ï¼Œæ¯æ¬¡å»æ“ä½œæ•°æ®æ—¶ï¼Œéƒ½è§‰å¾—åˆ«äººä¸­é€”ä¼šä¿®æ”¹ï¼Œæ‰€ä»¥æ¯æ¬¡åœ¨æ‹¿æ•°æ®çš„æ—¶å€™éƒ½ä¼šä¸Šé”ã€‚å®˜æ–¹ç‚¹è®²å°±æ˜¯ï¼Œå…±äº«èµ„æºæ¯æ¬¡åªç»™ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œå…¶å®ƒçº¿ç¨‹é˜»å¡ï¼Œç”¨å®Œåå†æŠŠèµ„æºè½¬è®©ç»™å…¶å®ƒçº¿ç¨‹ã€‚æ‚²è§‚é”å¦‚ä½•æ§åˆ¶å¹‚ç­‰çš„å‘¢ï¼Ÿå°±æ˜¯åŠ é”ï¼Œä¸€èˆ¬é…åˆäº‹åŠ¡æ¥å®ç°ã€‚ä¸¾ä¸ªæ›´æ–°è®¢å•çš„ä¸šåŠ¡åœºæ™¯
   å‡è®¾å…ˆæŸ¥å‡ºè®¢å•ï¼Œå¦‚æœæŸ¥åˆ°çš„æ˜¯å¤„ç†ä¸­çŠ¶æ€ï¼Œå°±å¤„ç†å®Œä¸šåŠ¡ï¼Œå†ç„¶åæ›´æ–°è®¢å•çŠ¶æ€ä¸ºå®Œæˆã€‚å¦‚æœæŸ¥åˆ°è®¢å•ï¼Œå¹¶ä¸”æ˜¯ä¸æ˜¯å¤„ç†ä¸­çš„çŠ¶æ€ï¼Œåˆ™ç›´æ¥è¿”å›

æµç¨‹å›¾ï¼š
[å›¾ç‰‡]


ä¼ªä»£ç ï¼š
- è¿™é‡Œé¢order_idéœ€è¦æ˜¯ç´¢å¼•æˆ–ä¸»é”®ï¼Œè¦é”ä½è¿™æ¡è®°å½•å°±å¥½ï¼Œå¦‚æœä¸æ˜¯ç´¢å¼•æˆ–è€…ä¸»é”®ï¼Œä¼šé”è¡¨çš„ï¼
- æ‚²è§‚é”åœ¨åŒä¸€äº‹åŠ¡æ“ä½œè¿‡ç¨‹ä¸­ï¼Œé”ä½äº†ä¸€è¡Œæ•°æ®ã€‚åˆ«çš„è¯·æ±‚è¿‡æ¥åªèƒ½ç­‰å¾…ï¼Œå¦‚æœå½“å‰äº‹åŠ¡è€—æ—¶æ¯”è¾ƒé•¿ï¼Œå°±å¾ˆå½±å“æ¥å£æ€§èƒ½ã€‚æ‰€ä»¥ä¸€èˆ¬ä¸å»ºè®®ç”¨æ‚²è§‚é”åšè¿™ä¸ªäº‹æƒ…ã€‚
  begin;  // 1.å¼€å§‹äº‹åŠ¡
  select * from order where order_id='666' for update // æŸ¥è¯¢è®¢å•ï¼Œåˆ¤æ–­çŠ¶æ€,é”ä½è¿™æ¡è®°å½•
  ifï¼ˆstatus !=å¤„ç†ä¸­ï¼‰{
  //éå¤„ç†ä¸­çŠ¶æ€ï¼Œç›´æ¥è¿”å›ï¼›
  return ;
  }
  // å¤„ç†ä¸šåŠ¡é€»è¾‘
  update order set status='å®Œæˆ' where order_id='666' // æ›´æ–°å®Œæˆ
  commit; // 5.æäº¤äº‹åŠ¡



7. ä¹è§‚é”
   æ¦‚å¿µï¼šå› ä¸ºæ‚²è§‚é”æœ‰æ€§èƒ½é—®é¢˜ï¼Œè¿™æ—¶å¯ä»¥å°è¯•ä¹è§‚é”ã€‚ä¹è§‚é”åœ¨æ“ä½œæ•°æ®æ—¶,åˆ™éå¸¸ä¹è§‚ï¼Œè®¤ä¸ºåˆ«äººä¸ä¼šåŒæ—¶åœ¨ä¿®æ”¹æ•°æ®ï¼Œå› æ­¤ä¹è§‚é”ä¸ä¼šä¸Šé”ã€‚åªæ˜¯åœ¨æ‰§è¡Œæ›´æ–°çš„æ—¶å€™åˆ¤æ–­ä¸€ä¸‹ï¼Œåœ¨æ­¤æœŸé—´åˆ«äººæ˜¯å¦ä¿®æ”¹äº†æ•°æ®ã€‚å…¶å®å°±æ˜¯ç»™è¡¨çš„åŠ å¤šä¸€åˆ—versionç‰ˆæœ¬å·ï¼Œæ¯æ¬¡æ›´æ–°è®°å½•versionéƒ½å‡çº§ä¸€ä¸‹ï¼ˆversion=version+1ï¼‰ã€‚å…·ä½“æµç¨‹å°±æ˜¯å…ˆæŸ¥å‡ºå½“å‰çš„ç‰ˆæœ¬å·versionï¼Œç„¶åå»æ›´æ–°ä¿®æ”¹æ•°æ®æ—¶ï¼Œç¡®è®¤ä¸‹æ˜¯ä¸æ˜¯åˆšåˆšæŸ¥å‡ºçš„ç‰ˆæœ¬å·ï¼Œå¦‚æœæ˜¯æ‰æ‰§è¡Œæ›´æ–°
   æµç¨‹å›¾ï¼š
   [å›¾ç‰‡]
   ä¼ªä»£ç ï¼š
   //æ›´æ–°å‰ï¼Œå…ˆæŸ¥æ•°æ®ï¼ŒæŸ¥å‡ºçš„ç‰ˆæœ¬å·æ˜¯version =1
   select order_idï¼Œversion from order where order_id='order_132123'ï¼›
   //ä½¿ç”¨version =1å’Œè®¢å•Idä¸€èµ·ä½œä¸ºæ¡ä»¶ï¼Œå†å»æ›´æ–°
   update order set version = version +1ï¼Œstatus='P' where  order_id='order_132123' and version =1
   //æœ€åæ›´æ–°æˆåŠŸï¼Œæ‰å¯ä»¥å¤„ç†ä¸šåŠ¡é€»è¾‘ï¼Œå¦‚æœæ›´æ–°å¤±è´¥ï¼Œé»˜è®¤ä¸ºé‡å¤è¯·æ±‚ï¼Œç›´æ¥è¿”å›ã€‚

8. åˆ†å¸ƒå¼é”
   æ¦‚å¿µï¼šåˆ†å¸ƒå¼é”å®ç°å¹‚ç­‰æ€§çš„é€»è¾‘å°±æ˜¯ï¼Œè¯·æ±‚è¿‡æ¥æ—¶ï¼Œå…ˆå»å°è¯•è·å¾—åˆ†å¸ƒå¼é”ï¼Œå¦‚æœè·å¾—æˆåŠŸï¼Œå°±æ‰§è¡Œä¸šåŠ¡é€»è¾‘ï¼Œåä¹‹è·å–å¤±è´¥çš„è¯ï¼Œå°±èˆå¼ƒè¯·æ±‚ç›´æ¥è¿”å›æˆåŠŸ/å¤„ç†ä¸­çŠ¶æ€ã€‚
- åˆ†å¸ƒå¼é”å¯ä»¥ä½¿ç”¨Redisï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ZooKeeperï¼Œä¸è¿‡è¿˜æ˜¯Redisç›¸å¯¹å¥½ç‚¹ï¼Œå› ä¸ºè¾ƒè½»é‡çº§ã€‚
- Redisåˆ†å¸ƒå¼é”ï¼Œå¯ä»¥ä½¿ç”¨å‘½ä»¤SET EX PX NX + å”¯ä¸€æµæ°´å·å®ç°ï¼Œåˆ†å¸ƒå¼é”çš„keyå¿…é¡»ä¸ºä¸šåŠ¡çš„å”¯ä¸€æ ‡è¯†å“ˆ
- Redisæ‰§è¡Œè®¾ç½®keyçš„åŠ¨ä½œæ—¶ï¼Œè¦è®¾ç½®è¿‡æœŸæ—¶é—´å“ˆï¼Œè¿™ä¸ªè¿‡æœŸæ—¶é—´ä¸èƒ½å¤ªçŸ­ï¼Œå¤ªçŸ­æ‹¦æˆªä¸äº†é‡å¤è¯·æ±‚ï¼Œä¹Ÿä¸èƒ½è®¾ç½®å¤ªé•¿ï¼Œä¼šå å­˜å‚¨ç©ºé—´ã€‚
  æµç¨‹å›¾ï¼š
  [å›¾ç‰‡]
  ä¼ªä»£ç ï¼š
  // å¹‚ç­‰æ€§å¤„ç† - åˆ†å¸ƒå¼é”æ–¹å¼
  func handleIdempotent(businessKey string) error {
  // 1. å°è¯•è·å–åˆ†å¸ƒå¼é”
  lockKey := "idempotent_lock:" + businessKey
  lockValue := generateUniqueValue()

  acquired := redis.SetNX(lockKey, lockValue, 30*time.Second) // 30ç§’è¿‡æœŸ
  if !acquired {
  // 2. è·å–é”å¤±è´¥ï¼Œç›´æ¥è¿”å›ã€‚æç¤ºç”¨æˆ·ç¨åå†è¯•æˆ–è®¢å•æ­£åœ¨å¤„ç†ä¸­ï¼ˆå®ç°å¹‚ç­‰æ€§ï¼‰
  return nil
  }

  // 3. è·å–é”æˆåŠŸï¼Œæ‰§è¡Œä¸šåŠ¡é€»è¾‘
  defer redis.Del(lockKey) // é‡Šæ”¾é”

  // æ‰§è¡Œå…·ä½“ä¸šåŠ¡å¤„ç†
  return processBusinessLogic()
  }



4.2 æ•´ä½“æ¡ˆä¾‹(åŸºäºtoken)
æ³¨æ„ï¼šä¸‹é¢ä»£ç ä¸»è¦æ¼”ç¤ºæ•´ä½“æµç¨‹ï¼Œé‡Œé¢ä»£ç å¹¶ééµå®ˆç”Ÿäº§ç¯å¢ƒçš„æ‰€æœ‰è§„èŒƒï¼Œå®é™…ä½¿ç”¨éœ€è¦ç»“åˆå„è‡ªä¸šåŠ¡åœºæ™¯ã€‚
æ•´ä½“æµç¨‹å›¾ï¼š
[å›¾ç‰‡]
ç¯å¢ƒå‡†å¤‡
å› ä¸ºéœ€è¦ç”¨åˆ°åˆ†å¸ƒå¼é”ï¼Œå› æ­¤éœ€è¦æœ¬åœ°æœ‰redisç¯å¢ƒï¼Œå¯ä»¥æœ¬åœ°ç›´æ¥å®‰è£…ä¹Ÿå¯ä»¥ä½¿ç”¨äº‘ä¸Šç¯å¢ƒã€‚æˆ‘è¿™é‡Œé€šè¿‡dockeræ­å»ºä¸€ä¸ªredisã€‚
docker run -d --name redis -v /Users/ziyi/docker-home/redis:/data -p 6379:6379 redis
[å›¾ç‰‡]

é¡¹ç›®ä»£ç 
1. main.go:
   package main

import (
"context"
"crypto/rand"
"encoding/hex"
"fmt"
"github.com/go-redis/redis"
"log"
"math/big"
"net/http"
"strings"
"sync"
"time"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
)

// PaymentStatus å®šä¹‰æ”¯ä»˜çŠ¶æ€
type PaymentStatus string

const (
StatusProcessing PaymentStatus = "PROCESSING"
StatusSuccess    PaymentStatus = "SUCCESS"
StatusFailed     PaymentStatus = "FAILED"
)

// PaymentRequest æ”¯ä»˜è¯·æ±‚ç»“æ„
type PaymentRequest struct {
IdempotentToken string  `json:"idempotent_token"`
Amount          float64 `json:"amount"`
UserID          string  `json:"user_id"`
Description     string  `json:"description"`
}

// PaymentResult æ”¯ä»˜ç»“æœç»“æ„
type PaymentResult struct {
Status    string `json:"status"`
Message   string `json:"message"`
OrderID   string `json:"order_id,omitempty"`
RequestID string `json:"request_id,omitempty"`
}

// PaymentRecord æ”¯ä»˜è®°å½•ç»“æ„
type PaymentRecord struct {
IdempotentKey string         `json:"idempotent_key"`
Status        PaymentStatus  `json:"status"`
Result        *PaymentResult `json:"result,omitempty"`
CreatedAt     time.Time      `json:"created_at"`
UpdatedAt     time.Time      `json:"updated_at"`
ErrorMessage  string         `json:"error_message,omitempty"`
}

// RedisLockService Redisåˆ†å¸ƒå¼é”æœåŠ¡
type RedisLockService struct {
client redis.Cmdable
ctx    context.Context
}

func NewRedisLockService(client redis.Cmdable) *RedisLockService {
return &RedisLockService{
client: client,
ctx:    context.Background(),
}
}

// generateLockValue ç”Ÿæˆé”çš„å”¯ä¸€æ ‡è¯†å€¼
func (r *RedisLockService) generateLockValue() (string, error) {
bytes := make([]byte, 16)
if _, err := rand.Read(bytes); err != nil {
return "", err
}
return hex.EncodeToString(bytes), nil
}

// AcquireLock è·å–åˆ†å¸ƒå¼é”
func (r *RedisLockService) AcquireLock(key string, expiration time.Duration) (string, bool) {
value, err := r.generateLockValue()
if err != nil {
return "", false
}

    // ä½¿ç”¨SETå‘½ä»¤çš„NXå’ŒEXé€‰é¡¹åŸå­æ€§åœ°è·å–é”
    success, err := r.client.SetNX(key, value, expiration).Result()
    if err != nil {
       return "", false
    }

    if !success {
       return "", false
    }

    return value, true
}

// TryAcquireLock å°è¯•è·å–åˆ†å¸ƒå¼é”ï¼Œæ”¯æŒç­‰å¾…æ—¶é—´
func (r *RedisLockService) TryAcquireLock(key string, waitTime, expiration time.Duration) (string, bool) {
value, acquired := r.AcquireLock(key, expiration)
if acquired {
return value, true
}

    // å¦‚æœè·å–é”å¤±è´¥ï¼Œåˆ™ç­‰å¾…å¹¶é‡è¯•
    deadline := time.Now().Add(waitTime)
    for time.Now().Before(deadline) {
       time.Sleep(50 * time.Millisecond) // çŸ­æš‚ä¼‘çœ é¿å…è¿‡åº¦ç«äº‰
       value, acquired := r.AcquireLock(key, expiration)
       if acquired {
          return value, true
       }
    }

    return "", false
}

// ReleaseLock é‡Šæ”¾åˆ†å¸ƒå¼é”ï¼ˆä½¿ç”¨Luaè„šæœ¬ç¡®ä¿åŸå­æ€§ï¼‰
func (r *RedisLockService) ReleaseLock(key, value string) bool {
// Luaè„šæœ¬åŸå­æ€§åœ°æ£€æŸ¥å¹¶åˆ é™¤é”
luaScript := `
if redis.call("GET", KEYS[1]) == ARGV[1] then
return redis.call("DEL", KEYS[1])
else
return 0
end
`

    result, err := r.client.Eval(luaScript, []string{key}, value).Result()
    if err != nil {
       return false
    }

    return result.(int64) == 1
}

// IsHeldByCurrent æ£€æŸ¥é”æ˜¯å¦ç”±å½“å‰å®ä¾‹æŒæœ‰
func (r *RedisLockService) IsHeldByCurrent(key, value string) bool {
val, err := r.client.Get(key).Result()
if err != nil {
return false
}
return val == value
}

// PaymentRepository æ”¯ä»˜è®°å½•å­˜å‚¨æ¥å£
type PaymentRepository interface {
GetPaymentRecord(idempotentKey string) *PaymentRecord
CreatePaymentRecord(idempotentKey string, record *PaymentRecord) error
UpdatePaymentRecord(idempotentKey string, status PaymentStatus, result *PaymentResult, errorMsg string) error
DeletePaymentRecord(idempotentKey string) error
}

// MemoryPaymentRepository å†…å­˜å­˜å‚¨å®ç°ï¼ˆæ¨¡æ‹Ÿæ•°æ®åº“ï¼‰
type MemoryPaymentRepository struct {
records map[string]*PaymentRecord
mutex   sync.RWMutex
}

func NewMemoryPaymentRepository() *MemoryPaymentRepository {
return &MemoryPaymentRepository{
records: make(map[string]*PaymentRecord),
}
}

/*
*

     å®é™…æ ¹æ®ä¸šåŠ¡åœºæ™¯æ¥ï¼š
     1. å¦‚æœåªéœ€è¦çŸ­æœŸå¹‚ç­‰ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠæ•°æ®å­˜åœ¨redisä¸­ï¼Œå¹¶è®¾ç½®TTLè¿‡æœŸæ—¶é—´
     2. å¦‚æœéœ€è¦é•¿æœŸå¹‚ç­‰ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠæ•°æ®å­˜åœ¨æ•°æ®åº“ä¸­
    *
*/
func (m *MemoryPaymentRepository) GetPaymentRecord(idempotentKey string) *PaymentRecord {
m.mutex.RLock()
defer m.mutex.RUnlock()

    if record, exists := m.records[idempotentKey]; exists {
       // è¿”å›å‰¯æœ¬é¿å…å¹¶å‘ä¿®æ”¹
       copy := *record
       if record.Result != nil {
          resultCopy := *record.Result
          copy.Result = &resultCopy
       }
       return &copy
    }
    return nil
}

func (m *MemoryPaymentRepository) CreatePaymentRecord(idempotentKey string, record *PaymentRecord) error {
m.mutex.Lock()
defer m.mutex.Unlock()

    if _, exists := m.records[idempotentKey]; exists {
       return fmt.Errorf("è®°å½•å·²å­˜åœ¨")
    }

    m.records[idempotentKey] = record
    return nil
}

func (m *MemoryPaymentRepository) UpdatePaymentRecord(idempotentKey string, status PaymentStatus, result *PaymentResult, errorMsg string) error {
m.mutex.Lock()
defer m.mutex.Unlock()

    if record, exists := m.records[idempotentKey]; exists {
       record.Status = status
       record.Result = result
       record.ErrorMessage = errorMsg
       record.UpdatedAt = time.Now()
       return nil
    }
    return fmt.Errorf("è®°å½•ä¸å­˜åœ¨")
}

func (m *MemoryPaymentRepository) DeletePaymentRecord(idempotentKey string) error {
m.mutex.Lock()
defer m.mutex.Unlock()

    delete(m.records, idempotentKey)
    return nil
}

// PaymentService æ”¯ä»˜æœåŠ¡
type PaymentService struct {
lockService LockService
repository  PaymentRepository
requestID   string
}

// LockService é”æœåŠ¡æ¥å£
type LockService interface {
AcquireLock(key string, expiration time.Duration) (string, bool)
TryAcquireLock(key string, waitTime, expiration time.Duration) (string, bool)
ReleaseLock(key, value string) bool
IsHeldByCurrent(key, value string) bool
}

func NewPaymentService(lockService LockService, repository PaymentRepository) *PaymentService {
return &PaymentService{
lockService: lockService,
repository:  repository,
}
}

// ProcessPaymentWithIdempotent å¤„ç†å¹‚ç­‰æ€§æ”¯ä»˜è¯·æ±‚
func (ps *PaymentService) ProcessPaymentWithIdempotent(request PaymentRequest) PaymentResult {
idempotentKey := request.IdempotentToken

    // å‚æ•°æ ¡éªŒã€‚é€šå¸¸é™¤äº†éªŒç©ºä¹‹å¤–ï¼Œè¿˜éœ€è¦éªŒè¯å¹‚ç­‰keyçš„æœ‰æ•ˆæ€§ï¼Œé˜²ç¯¡æ”¹ç­‰ã€‚
    // è¿™é‡Œä¸ºäº†ä»£ç ç®€å•å°±è·³è¿‡å¯¹keyçš„æœ‰æ•ˆæ€§æ ¡éªŒ
    if idempotentKey == "" {
       return PaymentResult{Status: "ERROR", Message: "ç¼ºå°‘å¹‚ç­‰token"}
    }

    // 1. å…ˆæŸ¥è¯¢æ˜¯å¦å·²æœ‰å¤„ç†ç»“æœã€‚
    // è¿™é‡Œå¯ä»¥æ ¹æ®ä¸šåŠ¡åœºæ™¯ä½¿ç”¨å¤šçº§ç¼“å­˜ï¼Œæ¯”å¦‚ å…ˆæŸ¥æœ¬åœ°ç¼“å­˜(L1ç¼“å­˜) -> æŸ¥è¯¢Redis(L2ç¼“å­˜) -> å†æŸ¥dbç­‰
    if existingRecord := ps.getPaymentRecord(idempotentKey); existingRecord != nil {
       switch existingRecord.Status {
       case StatusSuccess:
          result := *existingRecord.Result
          result.RequestID = ps.requestID
          return result
       case StatusProcessing:
          // æ£€æŸ¥æ˜¯å¦è¶…æ—¶ (é€šå¸¸è®¾ç½®ä¸ºä¸šåŠ¡å¤„ç†è¶…æ—¶æ—¶é—´)
          if time.Since(existingRecord.UpdatedAt) > 60*time.Second {
             // è¶…æ—¶ï¼Œå…è®¸é‡è¯•ï¼Œæ›´æ–°çŠ¶æ€ä¸ºå¤±è´¥
             ps.updateRecordStatus(idempotentKey, StatusFailed, nil, "å¤„ç†è¶…æ—¶")
          } else {
             return PaymentResult{
                Status:    "PROCESSING",
                Message:   "è¯·æ±‚æ­£åœ¨å¤„ç†ä¸­",
                RequestID: ps.requestID,
             }
          }
       case StatusFailed:
          // æ ¹æ®ä¸šåŠ¡å†³å®šæ˜¯å¦å…è®¸é‡è¯•
          if ps.allowRetry(request) {
             // æ¸…é™¤å¤±è´¥è®°å½•ï¼Œå…è®¸é‡è¯•
             ps.repository.DeletePaymentRecord(idempotentKey)
          } else {
             return PaymentResult{
                Status:    "FAILED",
                Message:   "è¯·æ±‚å·²å¤±è´¥ä¸”ä¸å¯é‡è¯•",
                RequestID: ps.requestID,
             }
          }
       }
    }

    // 2. è·å–åˆ†å¸ƒå¼é”
    lockKey := "payment_lock:" + idempotentKey
    lockValue, acquired := ps.lockService.TryAcquireLock(lockKey, 3*time.Second, 10*time.Second)
    if !acquired {
       return PaymentResult{
          Status:    "RETRY",
          Message:   "ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•", // è·å–é”å¤±è´¥ï¼Œå¯æç¤ºç”¨æˆ·ç¨åå†è¯• æˆ– è®¢å•æ­£åœ¨å¤„ç†ä¸­
          RequestID: ps.requestID,
       }
    }

    // ç¡®ä¿é”è¢«é‡Šæ”¾
    defer func() {
       if ps.lockService.IsHeldByCurrent(lockKey, lockValue) {
          ps.lockService.ReleaseLock(lockKey, lockValue)
       }
    }()

    // 3. åŒé‡æ£€æŸ¥ï¼šè·å–é”åå†æ¬¡æ£€æŸ¥
    if existingRecord := ps.getPaymentRecord(idempotentKey); existingRecord != nil {
       if existingRecord.Status == StatusSuccess {
          result := *existingRecord.Result
          result.RequestID = ps.requestID
          return result
       }
    }

    // 4. åˆ›å»ºå¤„ç†ä¸­è®°å½•
    if err := ps.createProcessingRecord(idempotentKey); err != nil {
       return PaymentResult{
          Status:    "ERROR",
          Message:   "åˆ›å»ºå¤„ç†è®°å½•å¤±è´¥: " + err.Error(),
          RequestID: ps.requestID,
       }
    }

    // 5. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    var result PaymentResult
    func() {
       defer func() {
          if r := recover(); r != nil {
             result = PaymentResult{
                Status:    "FAILED",
                Message:   "å¤„ç†è¿‡ç¨‹å‘ç”Ÿå¼‚å¸¸",
                RequestID: ps.requestID,
             }
             ps.repository.UpdatePaymentRecord(idempotentKey, StatusFailed, &result, "å¤„ç†è¿‡ç¨‹å‘ç”Ÿå¼‚å¸¸")
          }
       }()

       result = ps.executePayment(request)
       result.RequestID = ps.requestID
       ps.repository.UpdatePaymentRecord(idempotentKey, StatusSuccess, &result, "")
    }()

    return result
}

// getPaymentRecord è·å–æ”¯ä»˜è®°å½•
func (ps *PaymentService) getPaymentRecord(idempotentKey string) *PaymentRecord {
return ps.repository.GetPaymentRecord(idempotentKey)
}

// updateRecordStatus æ›´æ–°è®°å½•çŠ¶æ€
func (ps *PaymentService) updateRecordStatus(idempotentKey string, status PaymentStatus, result *PaymentResult, errorMsg string) {
ps.repository.UpdatePaymentRecord(idempotentKey, status, result, errorMsg)
}

// createProcessingRecord åˆ›å»ºå¤„ç†ä¸­è®°å½•
func (ps *PaymentService) createProcessingRecord(idempotentKey string) error {
record := &PaymentRecord{
IdempotentKey: idempotentKey,
Status:        StatusProcessing,
CreatedAt:     time.Now(),
UpdatedAt:     time.Now(),
}
return ps.repository.CreatePaymentRecord(idempotentKey, record)
}

// allowRetry æ˜¯å¦å…è®¸é‡è¯•ï¼ˆæ ¹æ®ä¸šåŠ¡éœ€æ±‚å®ç°ï¼‰
func (ps *PaymentService) allowRetry(request PaymentRequest) bool {
// æ ¹æ®ä¸šåŠ¡è§„åˆ™åˆ¤æ–­æ˜¯å¦å…è®¸é‡è¯•ï¼Œä¾‹å¦‚æ£€æŸ¥å¤±è´¥æ¬¡æ•°ç­‰
return true
}

// executePayment æ‰§è¡Œæ”¯ä»˜é€»è¾‘ï¼ˆæ¨¡æ‹Ÿï¼‰
func (ps *PaymentService) executePayment(request PaymentRequest) PaymentResult {
log.Printf("å¼€å§‹å¤„ç†æ”¯ä»˜è¯·æ±‚: ç”¨æˆ·=%s, é‡‘é¢=%.2f, æè¿°=%s",
request.UserID, request.Amount, request.Description)

    // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†æ—¶é—´ï¼ˆ100-500msï¼‰
    n, _ := rand.Int(rand.Reader, big.NewInt(400))
    time.Sleep(time.Duration(100+n.Int64()) * time.Millisecond)

    // æ¨¡æ‹Ÿéšæœºå¤±è´¥(5%æ¦‚ç‡å¤±è´¥)
    failureRate, _ := rand.Int(rand.Reader, big.NewInt(100))
    if failureRate.Int64() < 5 {
       log.Printf("æ”¯ä»˜å¤„ç†å¤±è´¥: ç”¨æˆ·=%s, é‡‘é¢=%.2f", request.UserID, request.Amount)
       return PaymentResult{
          Status:  "FAILED",
          Message: "æ”¯ä»˜ç½‘å…³æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•",
       }
    }

    orderID := "PAY_" + strings.ToUpper(uuid.New().String()[:8])
    log.Printf("æ”¯ä»˜å¤„ç†æˆåŠŸ: ç”¨æˆ·=%s, é‡‘é¢=%.2f, è®¢å•=%s",
       request.UserID, request.Amount, orderID)

    return PaymentResult{
       Status:  "SUCCESS",
       Message: fmt.Sprintf("æ”¯ä»˜æˆåŠŸï¼Œé‡‘é¢: %.2få…ƒ", request.Amount),
       OrderID: orderID,
    }
}

// HTTP handlers
type PaymentHandler struct {
paymentService *PaymentService
repository     PaymentRepository
}

func NewPaymentHandler(paymentService *PaymentService, repository PaymentRepository) *PaymentHandler {
return &PaymentHandler{
paymentService: paymentService,
repository:     repository,
}
}

func (h *PaymentHandler) ProcessPayment(c *gin.Context) {
var request PaymentRequest
if err := c.ShouldBindJSON(&request); err != nil {
c.JSON(http.StatusBadRequest, gin.H{"error": "æ— æ•ˆçš„è¯·æ±‚å‚æ•°: " + err.Error()})
return
}

    // ä¸ºæ¯æ¬¡è¯·æ±‚ç”Ÿæˆå”¯ä¸€IDç”¨äºè¿½è¸ª
    h.paymentService.requestID = "REQ_" + strings.ToUpper(uuid.New().String()[:8])

    result := h.paymentService.ProcessPaymentWithIdempotent(request)

    // æ ¹æ®çŠ¶æ€ç è¿”å›ä¸åŒçš„HTTPçŠ¶æ€
    var statusCode int
    switch result.Status {
    case "SUCCESS":
       statusCode = http.StatusOK
    case "PROCESSING":
       statusCode = http.StatusAccepted
    case "FAILED", "ERROR":
       statusCode = http.StatusInternalServerError
    case "RETRY":
       statusCode = http.StatusTooManyRequests
    default:
       statusCode = http.StatusOK
    }

    c.JSON(statusCode, result)
}

func (h *PaymentHandler) GetPaymentStatus(c *gin.Context) {
idempotentToken := c.Query("token")
if idempotentToken == "" {
c.JSON(http.StatusBadRequest, gin.H{"error": "ç¼ºå°‘tokenå‚æ•°"})
return
}

    record := h.repository.GetPaymentRecord(idempotentToken)
    if record == nil {
       c.JSON(http.StatusNotFound, gin.H{"error": "æœªæ‰¾åˆ°å¯¹åº”çš„æ”¯ä»˜è®°å½•"})
       return
    }

    c.JSON(http.StatusOK, record)
}

func (h *PaymentHandler) ListAllRecords(c *gin.Context) {
// è¿™é‡Œç®€å•è¿”å›æ‰€æœ‰è®°å½•ï¼ˆå®é™…ç”Ÿäº§ä¸­åº”è¯¥åˆ†é¡µï¼‰
c.JSON(http.StatusOK, h.repository.(*MemoryPaymentRepository).records)
}

func main() {
// åˆå§‹åŒ–Rediså®¢æˆ·ç«¯
redisClient := redis.NewClient(&redis.Options{
Addr: "localhost:6379",
DB:   0,
})

    // æµ‹è¯•Redisè¿æ¥
    if err := redisClient.Ping().Err(); err != nil {
       log.Fatal("æ— æ³•è¿æ¥åˆ°Redis: ", err)
    }
    log.Println("æˆåŠŸè¿æ¥åˆ°Redis")

    // åˆå§‹åŒ–æœåŠ¡
    lockService := NewRedisLockService(redisClient)
    repository := NewMemoryPaymentRepository()
    paymentService := NewPaymentService(lockService, repository)
    paymentHandler := NewPaymentHandler(paymentService, repository)

    // åˆå§‹åŒ–Ginè·¯ç”±å™¨
    r := gin.Default()

    // APIè·¯ç”±
    r.POST("/payment", paymentHandler.ProcessPayment)
    r.GET("/payment/status", paymentHandler.GetPaymentStatus)
    r.GET("/payment/records", paymentHandler.ListAllRecords)

    // å¥åº·æ£€æŸ¥
    r.GET("/health", func(c *gin.Context) {
       c.JSON(http.StatusOK, gin.H{"status": "healthy"})
    })

    log.Println("æœåŠ¡å™¨å¯åŠ¨åœ¨ç«¯å£ 8080")
    log.Println("API endpoints:")
    log.Println("  POST /payment - å¤„ç†æ”¯ä»˜è¯·æ±‚")
    log.Println("  GET  /payment/status?token={token} - æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€")
    log.Println("  GET  /payment/records - æŸ¥çœ‹æ‰€æœ‰æ”¯ä»˜è®°å½•")
    log.Println("  GET  /health - å¥åº·æ£€æŸ¥")

    if err := r.Run(":8080"); err != nil {
       log.Fatal("æœåŠ¡å™¨å¯åŠ¨å¤±è´¥: ", err)
    }
}
2. æµ‹è¯•è„šæœ¬
   test.sh:
# 1. ç”Ÿæˆå¹‚ç­‰token
TOKEN=$(uuidgen)
echo "ä½¿ç”¨token: $TOKEN"

# 2. å‘é€æ”¯ä»˜è¯·æ±‚
curl -X POST http://localhost:8080/payment \
-H "Content-Type: application/json" \
-d '{
"idempotent_token": "'$TOKEN'",
"amount": 100.50,
"user_id": "user_123",
"description": "æµ‹è¯•æ”¯ä»˜"
}'

# 3. ä½¿ç”¨ç›¸åŒtokenå†æ¬¡å‘é€ï¼ˆæµ‹è¯•å¹‚ç­‰æ€§ï¼‰
curl -X POST http://localhost:8080/payment \
-H "Content-Type: application/json" \
-d '{
"idempotent_token": "'$TOKEN'",
"amount": 100.50,
"user_id": "user_123",
"description": "æµ‹è¯•æ”¯ä»˜"
}'

# 4. æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€
curl "http://localhost:8080/payment/status?token=$TOKEN"

# 5. æŸ¥çœ‹æ‰€æœ‰è®°å½•
curl http://localhost:8080/payment/records

æµ‹è¯•éªŒè¯
1. ä»¥debugæ–¹å¼è¿è¡Œç¨‹åº
2. å‘èµ·è¯·æ±‚
# 1. ç”Ÿæˆå¹‚ç­‰token
TOKEN=$(uuidgen)
echo "ä½¿ç”¨token: $TOKEN"

# 2. å‘é€æ”¯ä»˜è¯·æ±‚
curl -X POST http://localhost:8080/payment \
-H "Content-Type: application/json" \
-d '{
"idempotent_token": "'$TOKEN'",
"amount": 100.50,
"user_id": "user_123",
"description": "æµ‹è¯•æ”¯ä»˜"
}'
3. é¦–å…ˆä¼šå»æ£€æŸ¥å½“å‰è®¢å•æ˜¯å¦æœ‰å¤„ç†ç»“æœ
   [å›¾ç‰‡]
   å¾ˆæ˜æ˜¾ï¼Œè¿™æ˜¯æˆ‘ä»¬ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼Œå› æ­¤è¿™ç¬”è®¢å•ä¸ä¼šæœ‰å¤„ç†ç»“æœã€‚ç„¶åæˆ‘ä»¬ä¼šå»è¯·æ±‚redisè·å–é”ï¼Œå› ä¸ºæ˜¯è¯¥ç¬”è®¢å•æ˜¯ç¬¬ä¸€æ¬¡è¿›æ¥ï¼Œæ‰€ä»¥å¯ä»¥è·å–é”æˆåŠŸã€‚
   [å›¾ç‰‡]
   redisè‡ªç„¶ä¹Ÿä¼šæœ‰å¯¹åº”çš„keyï¼š
   [å›¾ç‰‡]
   æœ€åèµ°è®¢å•å¤„ç†æµç¨‹ï¼Œå¤„ç†è®¢å•æˆåŠŸï¼š
   [å›¾ç‰‡]
   [å›¾ç‰‡]
4. æˆ‘ä»¬ä»¥ç›¸åŒè®¢å•å·é‡æ–°å‘é€è¯·æ±‚ï¼ŒéªŒè¯å¹‚ç­‰åŠŸèƒ½æ˜¯å¦æœ‰æ•ˆ
# ä½¿ç”¨token: B3C908D1-F5E7-4DC3-8BB8-9606138FB85B
TOKEN="B3C908D1-F5E7-4DC3-8BB8-9606138FB85B"

curl -X POST http://localhost:8080/payment \
-H "Content-Type: application/json" \
-d '{
"idempotent_token": "'$TOKEN'",
"amount": 100.50,
"user_id": "user_123",
"description": "æµ‹è¯•æ”¯ä»˜"
}'
5. å¯ä»¥çœ‹åˆ°æˆ‘ä»¬å·²ç»æŸ¥è¯¢ä¹‹å‰çš„è®¢å•è®°å½•ï¼Œä¸”çŠ¶æ€ä¸ºæˆåŠŸï¼Œå› æ­¤ä¼šç›´æ¥è¿”å›è®¢å•æˆåŠŸï¼Œä¹Ÿä¸ä¼šå»è¯·æ±‚redis
   [å›¾ç‰‡]

[å›¾ç‰‡]






5. å®é™…åº”ç”¨å»ºè®®
1. é¦–é€‰æ•°æ®åº“çº¦æŸï¼šåªè¦å¯èƒ½ï¼Œå°½é‡ä½¿ç”¨å”¯ä¸€ç´¢å¼•ä½œä¸ºå¹‚ç­‰çš„æœ€ç»ˆé˜²çº¿ã€‚å®ƒæ˜¯æ‰€æœ‰æ–¹æ¡ˆä¸­æœ€å¯é ã€æœ€ç®€å•çš„ã€‚
2. ç»„åˆä½¿ç”¨ï¼šä¸€ä¸ªå®Œæ•´çš„å¹‚ç­‰æ–¹æ¡ˆé€šå¸¸æ˜¯å¤šç§ç­–ç•¥çš„ç»„åˆã€‚
- ç¤ºä¾‹ï¼šå¤„ç†æ”¯ä»˜è¯·æ±‚æ—¶ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ï¼š
    - Tokenæ–¹æ¡ˆï¼šé˜²æ­¢å‰ç«¯é‡å¤æäº¤ã€‚
    - é˜²é‡è¡¨+å”¯ä¸€ç´¢å¼•ï¼šå¿«é€Ÿåˆ¤æ–­è¯·æ±‚æ˜¯å¦å·²å¤„ç†ã€‚
    - çŠ¶æ€æœº+ä¹è§‚é”ï¼šæ›´æ–°è®¢å•çŠ¶æ€ï¼Œé˜²æ­¢å¹¶å‘æ›´æ–°ã€‚
    - åˆ†å¸ƒå¼é”ï¼šåœ¨è·¨å¤šä¸ªæœåŠ¡çš„å¤æ‚ä¸šåŠ¡æµç¨‹ä¸­ï¼Œé”å®šå…³é”®èµ„æºã€‚
3. æ ¹æ®ä¸šåŠ¡åœºæ™¯é€‰æ‹©ï¼š
- åˆ›å»ºæ“ä½œï¼šé¦–é€‰ å”¯ä¸€ç´¢å¼•ã€‚
- æ›´æ–°æ“ä½œï¼šé¦–é€‰ çŠ¶æ€æœº å’Œ ä¹è§‚é”ã€‚
- åˆ†å¸ƒå¼ç¯å¢ƒï¼šå¿…é¡»å¼•å…¥ åˆ†å¸ƒå¼é” æˆ–åŸºäºRedisçš„Tokenæ–¹æ¡ˆã€‚
- å‰ç«¯äº¤äº’ï¼šä½¿ç”¨ Tokenä»¤ç‰Œ é˜²æ­¢ç”¨æˆ·é‡å¤ç‚¹å‡»ã€‚
  æ ¸å¿ƒæ€æƒ³ï¼šå¹‚ç­‰æ€§æ˜¯ä¸€ä¸ªéœ€è¦åœ¨å¤šä¸ªå±‚çº§ï¼ˆæ•°æ®åº“ã€åº”ç”¨ã€ä¸šåŠ¡ï¼‰å…±åŒè€ƒè™‘çš„ä½“ç³»åŒ–è®¾è®¡ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå•ä¸€çš„æŠ€æœ¯ç‚¹ã€‚




6. æ€»ç»“
   å¹‚ç­‰æ€§è®¾è®¡çš„æ ¸å¿ƒè¦ç‚¹ï¼š
1. å”¯ä¸€æ ‡è¯†ï¼šæ¯ä¸ªè¯·æ±‚å¿…é¡»æœ‰å”¯ä¸€å¹‚ç­‰key
2. çŠ¶æ€ç®¡ç†ï¼šæ˜ç¡®åŒºåˆ†å¤„ç†ä¸­ã€æˆåŠŸã€å¤±è´¥çŠ¶æ€
3. åŸå­æ“ä½œï¼šæ£€æŸ¥-æ‰§è¡Œ-ä¿å­˜ç»“æœéœ€è¦åŸå­æ€§
4. è¶…æ—¶æœºåˆ¶ï¼šå¤„ç†ä¸­çš„è¯·æ±‚éœ€è¦æœ‰è¶…æ—¶æ—¶é—´
5. å¯é‡è¯•æ€§ï¼šæ ¹æ®ä¸šåŠ¡éœ€æ±‚è®¾è®¡åˆç†çš„é‡è¯•æœºåˆ¶

æœ€ä½³å®è·µå»ºè®®ï¼š
1. å¯¹äºæ•æ„Ÿæ“ä½œï¼ˆæ”¯ä»˜ã€èµ„é‡‘å˜åŠ¨ç­‰ï¼‰ï¼šå¿…é¡»ç”±æœåŠ¡ç«¯ç”Ÿæˆå¸¦ç­¾åçš„å¹‚ç­‰Token
2. Tokenåº”åŒ…å«ï¼šç”¨æˆ·ä¿¡æ¯ã€æ—¶é—´æˆ³ã€éšæœºæ•°ã€ç­¾å
3. å¯¹äºä½é£é™©æ“ä½œï¼šå¯è€ƒè™‘æ¥å—å‰ç«¯ç”Ÿæˆçš„UUIDï¼Œä½†éœ€è¦ç»“åˆç”¨æˆ·ä¼šè¯éªŒè¯
4. å§‹ç»ˆéªŒè¯ï¼šæ— è®ºTokenæ¥è‡ªå“ªé‡Œï¼ŒæœåŠ¡ç«¯éƒ½å¿…é¡»éªŒè¯å…¶æœ‰æ•ˆæ€§å’Œåˆæ³•æ€§